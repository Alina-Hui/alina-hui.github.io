<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>数字</title>
      <link href="/2018/07/23/cjjydo33z0011k8vyj6c2dk1g/"/>
      <url>/2018/07/23/cjjydo33z0011k8vyj6c2dk1g/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Part of Speech</title>
      <link href="/2018/07/22/cjjydo33d000bk8vydps1tlxa/"/>
      <url>/2018/07/22/cjjydo33d000bk8vydps1tlxa/</url>
      <content type="html"><![CDATA[<h1 id="Verbs-Ⅰ"><a href="#Verbs-Ⅰ" class="headerlink" title="Verbs Ⅰ"></a>Verbs Ⅰ</h1><h2 id="系动词"><a href="#系动词" class="headerlink" title="系动词"></a>系动词</h2><p>系动词不能单独用作谓语，后边必须跟表语。</p><p>1.状态系动词be</p><p>2.持续系动词keep、reset、remain、stay、lie、stand等</p><p>3.变化系动词become、grow、turn、fall、get、go、come、run等</p><p>4.感官系动词feel、smell、sound、taste等</p><p>5.表象系动词seem、appear、look等</p><p>6.终止系动词prove、turn out等</p><h2 id="情态动词"><a href="#情态动词" class="headerlink" title="情态动词"></a>情态动词</h2><p>情态动词没有人称和数的变化，在居中不单独作谓语，必须和后面的动词原形合用。</p><p>常用的情态动词：can、may、must、need、should。</p><h2 id="助动词"><a href="#助动词" class="headerlink" title="助动词"></a>助动词</h2>]]></content>
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Grammar </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Equations of antiquity 古代的定理</title>
      <link href="/2018/07/14/cjjydo33u000uk8vyrmvhsqyi/"/>
      <url>/2018/07/14/cjjydo33u000uk8vyrmvhsqyi/</url>
      <content type="html"><![CDATA[<h1 id="Perface-序"><a href="#Perface-序" class="headerlink" title="Perface 序"></a>Perface 序</h1><p>公理：对未经证实的事实的陈述。</p><p>定理：根据特定公理体系正式推导所得的陈述，不受实验误差或认知方式的影响。</p><p>假说、猜想：尚未证明的数学陈述，但有支持这些陈述的实质性证据。</p><p>区分数学和实验科学包括物理、化学、生物的原则：数学中的事实永远不能用经验证据、表面上讲得通的道理或统计测试来证明。</p><p>数学的两重性：</p><p>   1.是因其本身而存在的一个知识体系。</p><p>   2.是表达宇宙知识的一种语言。</p><h1 id="The-world’s-simplest-equation-世界上最简单的公式"><a href="#The-world’s-simplest-equation-世界上最简单的公式" class="headerlink" title="The world’s simplest equation 世界上最简单的公式"></a>The world’s simplest equation 世界上最简单的公式</h1><p>对$1+1=2$这个公式通过集合论来解释的话大体意思就是：任何两个不相交的只有一个元素的集合的并集是一个有两个元素的集合。</p><p>等式的形成历史：公元250年前后(亚历山大港的丢番图；字母缩写)→16世纪后期(用x和y代表位置数量)→1557年(《砺智石》；“$=$”出现)</p><p>到了19世纪，数学家们意识到前辈依赖的假设并不一定为真。打破古代数学坚冰的第一道裂缝出现在19世纪初叶，非欧几何的发现。</p><p>“柏拉图主义者”的观点：数学以及我们研究的大量其它数学创造物，都代表了超越了人类思维的客观现实。（所以数学是自洽的，$1+1=2$没有矛盾性。）</p><h1 id="The-discovery-of-zero-零的发现"><a href="#The-discovery-of-zero-零的发现" class="headerlink" title="The discovery of zero 零的发现"></a>The discovery of zero 零的发现</h1>]]></content>
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>About this category</title>
      <link href="/2018/07/14/cjjydo32k0000k8vyo2ru31tz/"/>
      <url>/2018/07/14/cjjydo32k0000k8vyo2ru31tz/</url>
      <content type="html"><![CDATA[<p>[My English is really bad.]</p><p>I learned German in my freshman year, but I haven’t used it for a long time.</p><p>Thus I want to study German again.</p><p>This is the only reason why I need to set this category.</p>]]></content>
      
      <categories>
          
          <category> German </category>
          
      </categories>
      
      
        <tags>
            
            <tag> introduce </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>科目四</title>
      <link href="/2018/07/12/cjjydo33x000yk8vy6rc1p8t1/"/>
      <url>/2018/07/12/cjjydo33x000yk8vy6rc1p8t1/</url>
      <content type="html"><![CDATA[<h1 id="违法行为综合判断与案例分析-42题"><a href="#违法行为综合判断与案例分析-42题" class="headerlink" title="违法行为综合判断与案例分析(42题)"></a>违法行为综合判断与案例分析(42题)</h1><p>1.高速公路上发生故障，应该开启危险报警闪关灯后下车，在故障车后设置警示标志，联系保险公司或者维修店进行拖曳维修。货运车在高速上最高车速不超过100公里/小时。</p><p>2.鸣喇叭催促前方机动车不算违法行为。</p><p>3.通过急转弯减速靠右行驶。</p><p>4.机动车核载人数：大型客车20人以上；中型客车10-19人；小型客车少于9人；微型载客汽车8人以下。</p><p>5.高速公路大型客车最高限速110公里/小时。</p><p>6.A2驾驶证的准驾车型为牵引车，A2驾驶证还可以驾驶的车型有：B1、B2、C1、C2、C3、C4、M。</p><p>  B1：中型客车；B2：大型货车；C1：小型汽车；C2：小型自动挡骑车；C3：低速载货汽车；C4：三轮汽车；M：轮式自行机械车</p><p>7.最高行驶速度不超过30公里/小时(机动车)、15公里/小时(拖拉机、电瓶车、轮式专用机械车)的情况：</p><p>​    1）进出非机动车道，通过铁道路口、急弯、窄路、窄桥、交叉路口</p><p>​    2）掉头、转弯、下坡路</p><p>​    3）雾、雪、雨、沙尘、冰雹，能见度在50米以内</p><p>​    4）冰雪、泥泞的道路上</p><p>​    5）牵引发生故障的机动车</p><h1 id="安全行车常识-420题"><a href="#安全行车常识-420题" class="headerlink" title="安全行车常识(420题)"></a>安全行车常识(420题)</h1><p>1.驶出环岛，需先开启右转向灯。</p><p>2.驾驶机动车通过短而陡的上坡坡道时，采用加速冲坡的方法，在接近坡顶时应提前松开加速踏板，利用惯性冲过坡顶。</p><p>3.车辆涉水后，应保持低速，间接轻踏制动踏板，以恢复制动效果。</p><p>4.转弯让直行，右转让左转。</p><p>5.能见度$&lt; $200m，开启雾灯、近光灯、示廓灯、前后位灯，车速$\leq$60公里/小时，跟车距离$&gt;$100m;</p><p>​             $&lt; $100m，开启雾灯、近光灯、示廓灯、前后位灯、危险报警闪光灯，车速$\leq$40公里/小时，跟车距离$&gt;$50m;</p><p>​             $&lt; $50m，开启雾灯、近光灯、示廓灯、前后位灯、危险报警闪光灯，车速$\leq$20公里/小时，尽快驶离告诉路口。</p><p>6.上坡路段的安全距离应比平坦路段大。</p><p>7.下坡车让上坡。</p><h1 id="常见交通标志、标线和交通手势辨识-231题"><a href="#常见交通标志、标线和交通手势辨识-231题" class="headerlink" title="常见交通标志、标线和交通手势辨识(231题)"></a>常见交通标志、标线和交通手势辨识(231题)</h1><p>1.红灯亮，右转弯的车辆在不妨碍放行的车辆、行人通行的情况下可以通行。</p><p>2.左手：左转弯待转区，右手：减速慢行(上下摆动)、变更车道(水平摆动)</p><p>3.有红线的高速公路预告牌是指高速公路到了终点，没红线的是起点。</p><p>4.栅栏表示有人看守，火车头无人看守，一条红线50m。</p><p>5.标志：黄底是注意。</p><p>6.露天停车场：虚线为临时停车，实线为长时停车。</p><p>7.白色是最低车速，黄色是最高车速。</p><p>8.高速公路最低时速为60公里，最高$\leq$80公里。</p><p>  两车道：左侧车道最低时速100公里。</p><p>  三车道：最左侧的最低时速为110公里，中间的为90公里，最右侧的为60公里。</p><h1 id="驾驶职业道德和文明驾驶常识-169题"><a href="#驾驶职业道德和文明驾驶常识-169题" class="headerlink" title="驾驶职业道德和文明驾驶常识(169题)"></a>驾驶职业道德和文明驾驶常识(169题)</h1><h1 id="恶劣气候和复杂道路条件下驾驶常识-223题"><a href="#恶劣气候和复杂道路条件下驾驶常识-223题" class="headerlink" title="恶劣气候和复杂道路条件下驾驶常识(223题)"></a>恶劣气候和复杂道路条件下驾驶常识(223题)</h1><p>1.发生紧急故障必须停车时，要在应急车道停车。</p><p>2.驶离高速公路进入匝道时，应开启右转向灯。</p><p>3.刚下雨的路面最容易发生侧滑。</p><p>4.车辆在泥泞路段发生侧滑时，要向车尾侧滑方向缓打方向盘修正。</p><p>5.在有落石的危险路段，应该要注意观察，尽快通过。</p><p>6.上坡时候避免机动车后溜可将方向盘向左转，下坡的时候向右转。</p><p>7.上坡行驶应在车速下降前减挡保持充足动力。</p><p>8.在泥泞路段，要用加速踏板控制速度，匀速一次性通过。</p><h1 id="紧急情况下避险常识-112题"><a href="#紧急情况下避险常识-112题" class="headerlink" title="紧急情况下避险常识(112题)"></a>紧急情况下避险常识(112题)</h1><p>1.在冰雪路面上制动时车轮最容易抱死。</p><p>2.下坡路行车中制动突然失效可利用避险车道减速停车。</p><h1 id="交通事故救护及常见危化品处置常识-39题"><a href="#交通事故救护及常见危化品处置常识-39题" class="headerlink" title="交通事故救护及常见危化品处置常识(39题)"></a>交通事故救护及常见危化品处置常识(39题)</h1><p>1.高速公路上发生事故后人员应疏散到护栏外。</p><p>2.搬运昏迷失去知觉的伤员首先要放开起到，再采取仰卧位。</p><p>3.对无骨端外露的骨折伤员肢体固定时，要超过伤口上下关节。</p><p>4.救助全身燃烧的伤员应采取向身上喷冷水灭火的措施。</p><p>5.救助失血过多出现休克的伤员要采取保暖措施。</p><p>6.伤员骨折处出血时，应先止血和消毒，然后再固定。</p><p>7.烧伤伤员口渴时，可喝少量淡盐水。</p><p>8.采用指压止血法为动脉出血伤员止血时，拇指压住伤口的近心端动脉。</p><h1 id="防御性驾驶技术-100题"><a href="#防御性驾驶技术-100题" class="headerlink" title="防御性驾驶技术(100题)"></a>防御性驾驶技术(100题)</h1>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> driving test </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inside No.9 S01 E01</title>
      <link href="/2018/07/11/cjjydo3350005k8vyv7pgd495/"/>
      <url>/2018/07/11/cjjydo3350005k8vyv7pgd495/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Movies and TV shows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> teleplay_UK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>介绍Python对象类型</title>
      <link href="/2018/07/09/cjjydo33i000gk8vyo4tz9mdd/"/>
      <url>/2018/07/09/cjjydo33i000gk8vyo4tz9mdd/</url>
      <content type="html"><![CDATA[<p>[PS. 从第四章开始，笔记的内容会缩略很多，以后有空再考虑补上全部的吧。]</p><h1 id="为什么使用内置类型"><a href="#为什么使用内置类型" class="headerlink" title="为什么使用内置类型"></a>为什么使用内置类型</h1><h2 id="Python的核心数据类型"><a href="#Python的核心数据类型" class="headerlink" title="Python的核心数据类型"></a>Python的核心数据类型</h2><p>在Python程序中处理的每样东西都是一种对象。</p><p>Python中没有类型声明，运行的表达式的语法决定了创建和使用的对象的类型。</p><p>Python是动态类型(自动跟踪类型而不要求声明代码)的，但它也是强类型语言(只能对一个对象进行适合该类型的有效操作)。</p><h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><p>打印对象有两种形式：</p><ul><li><p>全精度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3.1415</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>用户友好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">3.1415</span>*<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串是单个字符的字符串的序列。</p><h2 id="序列的操作"><a href="#序列的操作" class="headerlink" title="序列的操作"></a>序列的操作</h2><p>在Python中可以进行反向索引，负的索引号会简单地与字符串的长度相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">-1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[len(s)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>分片(slice)操所：X[I:J]表示取出在X中从偏移量为I，直到但不包括偏移量为J的内容。</p><p>在一个分片中，左边界默认为0，右边界默认为分片序列的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'Spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:<span class="number">-1</span>]</span><br><span class="line"><span class="string">'Spa'</span></span><br></pre></td></tr></table></figure><h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>字符串在Python中具有不可变性。</p><h2 id="类型特定的方法"><a href="#类型特定的方法" class="headerlink" title="类型特定的方法"></a>类型特定的方法</h2><p>字符串支持一个叫格式化的高级替代操作，以一个表达式的形式和一个字符串方法调用形式使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%s,eggs,and %s'</span> % (<span class="string">'spam'</span>,<span class="string">'SPAM'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0&#125;,eggs,and &#123;1&#125;'</span> % (<span class="string">'spam'</span>,<span class="string">'SPAM'</span>)</span><br></pre></td></tr></table></figure><p>序列的操作是通用的，但是方法不通用。可用于多种类型的通用型操作都是以内置函数或表达式的形式出现的，如<code>len(x)</code>,类型特定的操作都是以方法调用的形式出现的，如<code>aString.upper()</code>。</p><h2 id="编写字符串的其它方法"><a href="#编写字符串的其它方法" class="headerlink" title="编写字符串的其它方法"></a>编写字符串的其它方法</h2><p>Python中字符串可以包括在单引号或双引号中，也允许在三个引号（单或双）中包括多行字符串常量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg=<span class="string">""" aaa</span></span><br><span class="line"><span class="string">bbb'''ccc""ddd'ee</span></span><br><span class="line"><span class="string">fff"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">' aaa\nbbb\'\'\'ccc""ddd\'ee\nfff'</span></span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>字符串对象的方法能够支持基于模式的文本处理，使用时需要导入一个re的模块，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>match=re.match(<span class="string">'Hello[\t]*(.*)world'</span>,<span class="string">'HelloPython world'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>match.group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'Python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>match=re.match(<span class="string">'/(.*)/(.*)/(.*)'</span>,<span class="string">'/usr/home/lumberjack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>match.groups()</span><br><span class="line">(<span class="string">'usr'</span>,<span class="string">'home'</span>,<span class="string">'lumberjack'</span>)</span><br></pre></td></tr></table></figure><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表是一个任意类型的对象的位置相关的有序集合，其大小可变，通过对偏移量进行赋值以及其他各种列表的方法进行调用能修改列表的大小。</p><h2 id="类型特定的操作"><a href="#类型特定的操作" class="headerlink" title="类型特定的操作"></a>类型特定的操作</h2><p>列表没有固定类型的约束，没有固定大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L=[<span class="number">123</span>,<span class="string">'spam'</span>,<span class="number">1.23</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.append(<span class="string">'NI'</span>)       <span class="comment">#Growing:add object at end of lisk</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">123</span>,<span class="string">'spam'</span>,<span class="number">1.23</span>,<span class="string">'NI'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.pop(<span class="number">2</span>)             <span class="comment">#Shrinking: delete an item in the middle = del L(2)</span></span><br><span class="line"><span class="number">1.23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">123</span>,<span class="string">'spam'</span>,<span class="string">'NI'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M=[<span class="string">'bb'</span>,<span class="string">'aa'</span>,<span class="string">'cc'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M.sort()            <span class="comment">#sort方法默认按照升序对列表进行排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M</span><br><span class="line">[<span class="string">'aa'</span>, <span class="string">'bb'</span>, <span class="string">'cc'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M.reverse()        <span class="comment">#reverse对列表进行翻转</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M</span><br><span class="line">[<span class="string">'cc'</span>, <span class="string">'bb'</span>, <span class="string">'aa'</span>]</span><br></pre></td></tr></table></figure><p>sort和reverse方法都直接对列表进行了改变。</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>Python核心数据类型的一个优秀的特性就是它们支持任意的嵌套，如实现多维数组(矩阵是按照行进行存储的)，但适合用于小规模的任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>M=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">              [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">              [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M[<span class="number">1</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h2><p>从矩阵中提取出第二列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>col2=[row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> M]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>col2</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>列表解析源自集合的概念，它由同一个变量名的表达式和循环结构组成，是编写在方括号中的。</p><p>更复杂的列表解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[row[<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">for</span> row <span class="keyword">in</span> M]</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> M <span class="keyword">if</span> row[<span class="number">1</span>]%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>列表解析创造了新的列表作为结果，能够在任何可迭代的对象上进行迭代。如用列表解析去步进坐标的一个硬编码列表和一个字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>diag=[M[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>diag</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doubles=[c*<span class="number">2</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'spam'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doubles</span><br><span class="line">[<span class="string">'ss'</span>, <span class="string">'pp'</span>, <span class="string">'aa'</span>, <span class="string">'mm'</span>]</span><br></pre></td></tr></table></figure><p>在新版本中，括号中的解析语法也可以用来创建生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>G=(sum(row) <span class="keyword">for</span> row <span class="keyword">in</span> M)                 <span class="comment"># create a generator of row sums</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(G)</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(sum,M))                          <span class="comment"># map sum over items in M</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">15</span>, <span class="number">24</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;sum(row) <span class="keyword">for</span> row <span class="keyword">in</span> M&#125;                   <span class="comment"># creat a set of row sums</span></span><br><span class="line">set([<span class="number">24</span>, <span class="number">6</span>, <span class="number">15</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;i:sum(M[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)&#125;           <span class="comment"># creats key/value table of row sums</span></span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">6</span>, <span class="number">1</span>: <span class="number">15</span>, <span class="number">2</span>: <span class="number">24</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[ord(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spaam'</span>]                 <span class="comment"># list of character ordinals</span></span><br><span class="line">[<span class="number">115</span>, <span class="number">112</span>, <span class="number">97</span>, <span class="number">97</span>, <span class="number">109</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;ord(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spaam'</span>&#125;                 <span class="comment"># sets remove duplicates</span></span><br><span class="line">set([<span class="number">112</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x:ord(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'spaam'</span>&#125;               <span class="comment"># dictionary keys are unique</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">97</span>, <span class="string">'p'</span>: <span class="number">112</span>, <span class="string">'s'</span>: <span class="number">115</span>, <span class="string">'m'</span>: <span class="number">109</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="映射操作"><a href="#映射操作" class="headerlink" title="映射操作"></a>映射操作</h2><p>字典编写在大括号中，索引操作的语法和序列相同，但方括号中的元素是键。字典并不包含任何可靠的从左到右的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>D=&#123;<span class="string">'f'</span>:<span class="string">'s'</span>,<span class="string">'q'</span>:<span class="number">4</span>,<span class="string">'c'</span>:<span class="string">'p'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D[<span class="string">'f'</span>]</span><br><span class="line"><span class="string">'s'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D[<span class="string">'q'</span>]+=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D</span><br><span class="line">&#123;<span class="string">'q'</span>: <span class="number">5</span>, <span class="string">'c'</span>: <span class="string">'p'</span>, <span class="string">'f'</span>: <span class="string">'s'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="重访嵌套"><a href="#重访嵌套" class="headerlink" title="重访嵌套"></a>重访嵌套</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec=&#123;<span class="string">'name'</span>:&#123;<span class="string">'first'</span>:<span class="string">'bob'</span>,<span class="string">'last'</span>:<span class="string">'smith'</span>&#125;,</span><br><span class="line">                <span class="string">'job'</span>:[<span class="string">'dev'</span>,<span class="string">'mgr'</span>],</span><br><span class="line">                <span class="string">'age'</span>:<span class="number">40</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec[<span class="string">'name'</span>]</span><br><span class="line">&#123;<span class="string">'last'</span>: <span class="string">'smith'</span>, <span class="string">'first'</span>: <span class="string">'bob'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec[<span class="string">'name'</span>][<span class="string">'last'</span>]</span><br><span class="line"><span class="string">'smith'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec[<span class="string">'job'</span>][<span class="number">-1</span>]</span><br><span class="line"><span class="string">'mgr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec[<span class="string">'job'</span>].append(<span class="string">'janitor'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">40</span>, <span class="string">'job'</span>: [<span class="string">'dev'</span>, <span class="string">'mgr'</span>, <span class="string">'janitor'</span>], <span class="string">'name'</span>: &#123;<span class="string">'last'</span>: <span class="string">'smith'</span>, <span class="string">'first'</span>: <span class="string">'bob'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>Python具有垃圾收集的特性，一旦一个对象的最后一次引用被移除，空间将会立即回收，所以可以自由地使用对象。</p><h2 id="键的排序：for循环"><a href="#键的排序：for循环" class="headerlink" title="键的排序：for循环"></a>键的排序：for循环</h2><p>在一个字典元素中如果想强调某种顺序可以用如下方法：</p><p>1.keys→sort→for</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>D=&#123;<span class="string">'f'</span>:<span class="string">'s'</span>,<span class="string">'q'</span>:<span class="number">4</span>,<span class="string">'c'</span>:<span class="string">'p'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k=list(D.keys())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k</span><br><span class="line">[<span class="string">'q'</span>, <span class="string">'c'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k</span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'f'</span>, <span class="string">'q'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> k:</span><br><span class="line">print(key,<span class="string">'=&gt;'</span>,D[key])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'=&gt;'</span>, <span class="string">'p'</span>)</span><br><span class="line">(<span class="string">'f'</span>, <span class="string">'=&gt;'</span>, <span class="string">'s'</span>)</span><br><span class="line">(<span class="string">'q'</span>, <span class="string">'=&gt;'</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>2.sorted</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>D</span><br><span class="line">&#123;<span class="string">'q'</span>: <span class="number">4</span>, <span class="string">'c'</span>: <span class="string">'p'</span>, <span class="string">'f'</span>: <span class="string">'s'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> sorted(D):</span><br><span class="line">print(key,<span class="string">'=&gt;'</span>,D[key])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'=&gt;'</span>, <span class="string">'p'</span>)</span><br><span class="line">(<span class="string">'f'</span>, <span class="string">'=&gt;'</span>, <span class="string">'s'</span>)</span><br><span class="line">(<span class="string">'q'</span>, <span class="string">'=&gt;'</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="迭代和优化"><a href="#迭代和优化" class="headerlink" title="迭代和优化"></a>迭代和优化</h2><p>从左到右地扫描一个对象的每个Python工具都使用迭代协议。</p><p>例子：计算一列数字的平方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure><h2 id="不存在的键：if测试"><a href="#不存在的键：if测试" class="headerlink" title="不存在的键：if测试"></a>不存在的键：if测试</h2><p>查询字典中的一个键是否存在的方法：</p><p>1.in关系表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'S'</span> <span class="keyword">in</span> D</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>2.if</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">not</span> <span class="string">'S'</span> <span class="keyword">in</span> D:</span><br><span class="line">print(<span class="string">'missing'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">missing</span><br></pre></td></tr></table></figure><p>3.get</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>value=D.get(<span class="string">'x'</span>,<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value=D[<span class="string">'x'</span>] <span class="keyword">if</span> <span class="string">'x'</span> <span class="keyword">in</span> D <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组像一个不可改变的序列，和字符串类似，编写在圆括号中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(t)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t+(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="为什么要用元组"><a href="#为什么要用元组" class="headerlink" title="为什么要用元组"></a>为什么要用元组</h2><p>元组提供了一种完整性的约束。</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>创建一个文本输出文件并以‘w’模式写数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f=open(<span class="string">'data.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">'hello\n'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p>读出刚才所写的内容，以‘r’模式打开文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f=open(<span class="string">'data.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text=f.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">'hello\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(text)</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.split()</span><br><span class="line">[<span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure><p>如今读取文件的最佳方法是用迭代器。</p><h2 id="其它文件类工具"><a href="#其它文件类工具" class="headerlink" title="其它文件类工具"></a>其它文件类工具</h2><p>如描述符文件支持文件锁定和其它的底层工具，套接字提供网络和进程间通信的接口。</p><h1 id="其他核心类型"><a href="#其他核心类型" class="headerlink" title="其他核心类型"></a>其他核心类型</h1><p>1.集合：唯一不可变的对象的无需集合，通过set函数创建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x=set(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y=&#123;<span class="string">'h'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x,y</span><br><span class="line">(set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'s'</span>, <span class="string">'m'</span>]), set([<span class="string">'a'</span>, <span class="string">'h'</span>, <span class="string">'m'</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x&amp;y</span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'m'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x|y</span><br><span class="line">set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'m'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x-y</span><br><span class="line">set([<span class="string">'p'</span>, <span class="string">'s'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line">set([<span class="number">16</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>2.十进制数（固定精度浮点数）和分数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=decimal.Decimal(<span class="string">'3.141'</span>)                        <span class="comment"># decimals:fixed precision</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d+<span class="number">1</span></span><br><span class="line">Decimal(<span class="string">'4.141'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>decimal.getcontext().prec=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>decimal.Decimal(<span class="string">'1.00'</span>)/decimal.Decimal(<span class="string">'3.00'</span>)</span><br><span class="line">Decimal(<span class="string">'0.33'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction                    <span class="comment"># fractions:numerator+denominator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f=Fraction(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f+<span class="number">1</span></span><br><span class="line">Fraction(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f+Fraction(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">Fraction(<span class="number">7</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>3.布尔值和None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>&gt;<span class="number">2</span>,<span class="number">1</span>&lt;<span class="number">2</span></span><br><span class="line">(<span class="keyword">False</span>, <span class="keyword">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">'spam'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2 id="如何破坏代码的灵活性"><a href="#如何破坏代码的灵活性" class="headerlink" title="如何破坏代码的灵活性"></a>如何破坏代码的灵活性</h2><p>在代码中检验了特定的类型，实际上破坏了它的灵活性，限制它只能用一种类型工作。</p><h2 id="用户定义的类"><a href="#用户定义的类" class="headerlink" title="用户定义的类"></a>用户定义的类</h2><p>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">worker</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self,name,pay)</span>:</span></span><br><span class="line">self.name=name</span><br><span class="line">self.pay=pay</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastname</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveraise</span><span class="params">(self,percent)</span>:</span></span><br><span class="line">self.pay*=(<span class="number">1.0</span>+percent)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Overview of Supervised Learning</title>
      <link href="/2018/07/09/cjjydo33b000ak8vywio00z4l/"/>
      <url>/2018/07/09/cjjydo33b000ak8vywio00z4l/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_English </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>部署操作系统</title>
      <link href="/2018/07/08/cjjydo3a7002ak8vy7gdm8l0w/"/>
      <url>/2018/07/08/cjjydo3a7002ak8vy7gdm8l0w/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Artificial Intelligence：Its Roots and Scope</title>
      <link href="/2018/07/08/cjjydo32p0001k8vyx462f0qe/"/>
      <url>/2018/07/08/cjjydo32p0001k8vyx462f0qe/</url>
      <content type="html"><![CDATA[<blockquote><p><em>Invention, it must be humbly admitted, does not consist in creating out of void, but out of chaos; the materials must, in the first place, be afforded….</em> </p><p>—MARY SHELLEY, Frankenstein</p></blockquote><h2 id="Artificial-Intelligence-An-Attempted-Definition"><a href="#Artificial-Intelligence-An-Attempted-Definition" class="headerlink" title="Artificial Intelligence: An Attempted Definition"></a>Artificial Intelligence: An Attempted Definition</h2><p>For many reasons, the initial definition of artificial intelligence falls short of unambiguously defining the field. If anything, it has only led to further questions and the paradoxical notion of a field of study whose major goals include its own definition.</p><p>For the time being, we will simply define AI as the collection of problems and methodologies studied by AI researchers.</p><h1 id="AI-EARLY-HISTORY-AND-APPLICATIONS"><a href="#AI-EARLY-HISTORY-AND-APPLICATIONS" class="headerlink" title="AI: EARLY HISTORY AND APPLICATIONS"></a>AI: EARLY HISTORY AND APPLICATIONS</h1><blockquote><p><em>All men by nature desire to know…</em></p><p>—ARISTOTLE, Opening sentence of the <em>Metaphysics</em></p></blockquote><h2 id="From-Eden-to-ENIAC-Attitude-toward-Intelligence-Knowledge-and-Human-Artifice"><a href="#From-Eden-to-ENIAC-Attitude-toward-Intelligence-Knowledge-and-Human-Artifice" class="headerlink" title="From Eden to ENIAC: Attitude toward Intelligence,Knowledge, and Human Artifice"></a>From Eden to ENIAC: Attitude toward Intelligence,Knowledge, and Human Artifice</h2><h3 id="A-Brief-History-of-the-Foundations-for-AI"><a href="#A-Brief-History-of-the-Foundations-for-AI" class="headerlink" title="A Brief History of the Foundations for AI"></a>A Brief History of the Foundations for AI</h3>]]></content>
      
      <categories>
          
          <category> Artificial Intelligence </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_English </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>隐马尔可夫模型</title>
      <link href="/2018/07/07/cjjydo3ac002ek8vyzxxjaj3u/"/>
      <url>/2018/07/07/cjjydo3ac002ek8vyzxxjaj3u/</url>
      <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>隐马尔可夫模型是关于时序的概率模型，可用于标注问题 (状态对应标记)，描述由隐藏的马尔可夫链随机生成观测序列的过程 (一个隐藏的马尔可夫链随机生成不可观测的状态随机序列→由各个状态生成一个观测而产生观测随机序列)，属于生成模型。</p><p>序列的每一个位置又可以看作是一个时刻。</p><p>隐马尔可夫模型由初始概率分布、状态转移分布、观测概率分布确定，所以初始状态概率向量$\pi$、状态转移概率矩阵$A$、观测概率矩阵$B$为隐马尔可夫模型$\lambda$的三要素：</p><center>$\lambda=(A,B,\pi)$</center><p>其中，初始状态概率向量$\pi$和状态转移概率矩阵$A$决定状态序列 (状态序列是隐藏的)，观测概率矩阵$B$决定观测序列。</p><center>$A=[a_{ij}]_{N \times M}$</center><p>$a_{ij}=P(i_{i+1}=q_i | i_t=q_i); i=1,2 \cdots ,N; j=1,2, \cdots ,N$ 代表时刻$t$处于状态$q_i$的条件下在时刻$t+1$转移到状态$q_j$的概率。$N$是可能的状态数，$M$是可能的观测数。</p><center>$B=[b_j(k)]_{N \times M}$</center><p>$b_j(k)=P(o_t=v_k | i_t=q_j) ; k=1,2, \cdots ,M ; j=1,2, \cdots ,N$ 是时刻$t$处于状态$q_j$的条件下生成观测$v_k$的概率。</p><center>$\pi =(\pi_i)$</center><p>$\pi =P(i_1=q_i),i=1,2, \cdots ,N$ 是时刻$t$=1处于状态$q_i$的概率。</p><p>$A$与$\pi$决定了隐藏的马尔可夫链，生成不可观测的状态序列。$B$确定了如何从状态生成观测，与状态序列综合确定了如何产生观测序列。</p><p>隐马尔可夫模型做了两个基本假设：</p><ol><li>齐次马尔可夫性假设：<strong>隐藏的马尔可夫链</strong>在任意时刻t的状态只依赖于<strong>前一时刻的状态</strong>。</li><li>观测独立性假设：任意时刻的<strong>观测</strong>只依赖于<strong>该时刻的马尔可夫链的状态</strong>。</li></ol><h2 id="观测序列的生成过程"><a href="#观测序列的生成过程" class="headerlink" title="观测序列的生成过程"></a>观测序列的生成过程</h2><p>输入：$\lambda=(A,B,\pi)$，观测序列长度$T$;</p><p>输出：观测序列$O=(o_1,o_2, \cdots ,o_T)$</p><p>​    (1)按照初始状态分布$\pi$产生状态$i_1$</p><p>​    (2)另$t=1$</p><p>​    (3)按照状态$i_t$的观测概率分布$b_{i_t}(k)$生成$o_t$</p><p>​    (4)按照状态$i_t$的状态转移概率分布$\{ a_{i_t i_{t+1}} \}$产生状态 $i_{t+1},i_{t+1}=1,2, \cdots ,N$</p><p>​    (5)令$t=t+1$; 如果$t&lt;T$, 转步(3)；否则，终止</p><p>即生成初始状态分布→生成观测概率分布→生成状态概率分布</p><h2 id="模型的三个基本问题"><a href="#模型的三个基本问题" class="headerlink" title="模型的三个基本问题"></a>模型的三个基本问题</h2><p>1.概率计算问题：给定模型$\lambda$和长度为T的观测序列$O=(o_1,o_2, \cdots ,o_T)$，计算模型$\lambda$下观测序列$O$出现的概率$P(O|\lambda)$。</p><p>2.学习问题(用极大似然估计的方法估计参数)：已知观测序列，估计模型的参数，使得在该模型下观测序列概率$P$最大。</p><p>3.预测问题(解码问题;给定观测序列，求最有可能的对应的状态序列)：已知模型和观测序列，求对给定观测序列条件概率$P(I | O)$最大的状态序列$I=(i_1,i_2, \cdots ,i_T)$。</p><h1 id="概率计算算法"><a href="#概率计算算法" class="headerlink" title="概率计算算法"></a>概率计算算法</h1>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Mathjax</title>
      <link href="/2018/07/06/cjjydo33n000mk8vyws7u4471/"/>
      <url>/2018/07/06/cjjydo33n000mk8vyws7u4471/</url>
      <content type="html"><![CDATA[<p>NexT有自带Mathjax，所以启用Mathjax的方法也非常简单，只要修改主题目录内_config.yml中的MathJax Support</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><p>注意：三句都得修改。</p>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用什么工具写博客</title>
      <link href="/2018/07/06/cjjydo33r000sk8vyk6q41nr3/"/>
      <url>/2018/07/06/cjjydo33r000sk8vyk6q41nr3/</url>
      <content type="html"><![CDATA[<p>我在写博客的过程中使用到了两种工具：Typora和Sublime</p><p>Sublime就不用多说了，Typora比Sublime好的一点在于它所见即所得。用两个编辑器写出来的博文格式也有点区别,Sublime没有那么支持中文。</p><p>但是如果用了本地预览，用Sublime修改博文可以立马看到效果，而Typora就无法得到(修改的那篇博文会编程Untitled)，需要重新启用hexo s。</p><p>为了能够得到所见即所得的效果，我后来使用了Typora作为写博客的工具，但是在使用过程中我发现在用Typora编辑博文时不小心把源文件给删掉了，Typora中编辑好的、保存过的文件内容也会一并消失，需要在偏好设置里手动勾选自动保存按钮，而使用Sublime并不会出现这种问题。</p><p>个人觉得为了保险起见还是应该把博文做个备份，可以把所有博文投放在另一个博客平台上，也可以在电脑里专门建一个备份文件夹，把所有源文件复制进去。</p><p>如果想直接在电脑里备份，为了方便可以用上批处理(xcopy)和计划任务(taskschd.msc)，可以省力不少。</p>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我们的宇宙图像</title>
      <link href="/2018/07/03/cjjydo33o000ok8vyt8z4xej0/"/>
      <url>/2018/07/03/cjjydo33o000ok8vyt8z4xej0/</url>
      <content type="html"><![CDATA[<p>早在公元前340年，希腊哲学家亚里士多德在他的《论天》一书中，就能够对于地球是一个圆球而不是一块平板这个信念提出两个有力的论证:</p><ul><li><strong>月食是由于地球运行到太阳与月亮之间引起的</strong>。地球在月亮上的影子总是圆的，这只有在地球本身为球形的前提下才成立。 加果地球是一块平坦的圆盘，除非月食总是发生在太阳正好位于这个圆盘中心的正下方的时刻，否则地球的影子就会被拉长而成为椭圆形。 </li><li>希腊人从旅行中知道，<strong>在南方观测北极星，比在较北地区，北极星在天空中显得较低。</strong>因为北极星位于北极的正上方，所以它出现在北极的观察者的头顶上，而对于赤道上的某观察者，北极星刚好出现在地平线上 </li></ul>]]></content>
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> astronomy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>绪论</title>
      <link href="/2018/07/03/cjjydo3440018k8vy1c1aic4y/"/>
      <url>/2018/07/03/cjjydo3440018k8vy1c1aic4y/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NexT主题内建归档categories时出现的bug</title>
      <link href="/2018/07/03/cjjydo3330004k8vyr65ungvp/"/>
      <url>/2018/07/03/cjjydo3330004k8vyr65ungvp/</url>
      <content type="html"><![CDATA[<p>我建博客的目的是为了把我的读书笔记迁移下，然后个人更偏爱把各分类放在menu里而不是categories里，所以使用了<a href="https://www.zhihu.com/question/33324071" target="_blank" rel="noopener">内建归档categories</a>。 </p><p>在本地预览时一切ok，但是当我上传到github之后自定义的分类menu无法打开，总是出现404错误，试过了n多方法，网上也搜了一大圈，可是就是无法解决这个bug。</p><p>之后我把../public/categories/…里所有的index.html都打开来看了一遍，并没有发现什么问题，然后试着把artificial-intelligence文件夹(我categories里第一个归档文件夹就是这个)里的index.html复制黏贴替换了categories文件夹里的index.html(categories里的归档文件夹数目根据分类个数而定，但是index.html只有一个)。</p><p>然后重新上传了一次，bug没了…..</p><p>╮(╯▽╰)╭</p>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/2018/07/02/cjjydo3a40028k8vy67i5dij4/"/>
      <url>/2018/07/02/cjjydo3a40028k8vy67i5dij4/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Computer Networks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>统计学习方法概论</title>
      <link href="/2018/07/01/cjjydo3410013k8vyga57lkgi/"/>
      <url>/2018/07/01/cjjydo3410013k8vyga57lkgi/</url>
      <content type="html"><![CDATA[<h1 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>建立在计算机及网络之上</li><li>以数据为研究对象</li><li>目的是对数据进行预测与分析</li><li>以方法为中心</li></ol><p>按照Herbert A.Simon的观点，统计学习是计算机系统通过运用数据及统计方法提高系统性能的机器学习。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>统计学习(统计机器学习 Statistical Machine Learning)关于数据的假设(也是统计学习的前提)是同类数据(同种性质的数据)具有一定的统计规律性。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>假设空间(hypothesis space)：</strong>学习模型的集合。<br><strong>统计学习方法的三要素：</strong>模型(model;模型的假设空间)、策略(strategy;模型选择的准则)、算法(algorithm;模型学习的算法)<br><strong>实现统计学习方法的步骤：</strong> 得到有限的训练数据集合→确定学习模型的集合→确定学习的策略→实现学习的算法→选择最优模型→对数据进行预测或分析</p><h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>实例通常由特征向量表示，模型实际都是定义在特征空间上的。<br><strong>回归问题：</strong>输入变量与输出变量均为连续变量。<br><strong>分类问题：</strong>输出变量为有限个离散变量。<br><strong>标注问题：</strong>输入变量与输出变量均为变量序列。<br>监督学习关于数据的基本假设是输入与输出的随机变量X和Y具有联合概率分布。(训练数据与测试数据被看作是依联合概率分布P(X,Y)独立同分布产生的)</p><h1 id="统计学习三要素"><a href="#统计学习三要素" class="headerlink" title="统计学习三要素"></a>统计学习三要素</h1><p> 方法=模型+策略+算法</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>非概率模型由决策函数表示，概率模型由条件概率表示</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p><strong>损失函数：</strong>度量模型一次预测的好坏。<br><strong>风险函数：</strong>度量平均意义下模型预测的好坏。</p><h3 id="损失函数和风险函数"><a href="#损失函数和风险函数" class="headerlink" title="损失函数和风险函数"></a>损失函数和风险函数</h3>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction About AI</title>
      <link href="/2018/06/30/cjjydo3370006k8vysmbh7rfa/"/>
      <url>/2018/06/30/cjjydo3370006k8vysmbh7rfa/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Artificial Intelligence </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_English </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python使用入门及如何运行</title>
      <link href="/2018/06/28/cjjydo33k000ik8vy3pm45u7e/"/>
      <url>/2018/06/28/cjjydo33k000ik8vy3pm45u7e/</url>
      <content type="html"><![CDATA[<p>这篇没涉及什么技术性知识，只是用于帮助了解Python而已。</p><h1 id="选择Python的主要因素"><a href="#选择Python的主要因素" class="headerlink" title="选择Python的主要因素"></a>选择Python的主要因素</h1><p>软件质量、提高开发者的效率、程序的可移植性、标准库的支持、组件集成、享受乐趣</p><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>Python的特性是以统一并有限的方式进行交互。<br>Python的设计理念是极简主义，”EIBTI”，明了胜于晦涩。(import this)</p><h1 id="Python的定义"><a href="#Python的定义" class="headerlink" title="Python的定义"></a>Python的定义</h1><p>Python一般可以定义为面向对象的脚本语言。<br>“脚本”倾向于描述简单的顶层代码文件，”程序”用来描述相对复杂的多文件应用。<br>Python的三个角色：Shell工具、控制语言(常规角色)、使用便捷(通常应用于快速作业任务和长期战略开发)</p><h1 id="Python的缺点"><a href="#Python的缺点" class="headerlink" title="Python的缺点"></a>Python的缺点</h1><p>速度没C和C++快，因为Python没有将代码编译成底层的二进制代码。<br>在一些需要优化程序执行速度的应用领域，如数值计算和动画，可以通过分离一部分需要优化速度的应用，将其变化为编译好的扩展，仍可以使用Python。</p><h1 id="程序执行-Python视角"><a href="#程序执行-Python视角" class="headerlink" title="程序执行-Python视角"></a>程序执行-Python视角</h1><h2 id="字节码编译，PVM，性能和开发的含义"><a href="#字节码编译，PVM，性能和开发的含义" class="headerlink" title="字节码编译，PVM，性能和开发的含义"></a>字节码编译，PVM，性能和开发的含义</h2><p><strong>解释器：</strong>代码和机器的计算机硬件之间的软件逻辑层<br><strong>python的运行步骤:</strong> 源代码(.py)→字节码(.pyc)→PVM(Python Virtual Machine)<br>PVM实际上是迭代运行字节码指令的一个大循环，是Python的运行引擎，是实际运行脚本的组建。<br>Python的字节码非机器的二进制代码，它具有可移植性。<br>Python没有”build”和”make”步骤，代码在写好之后立即运行，所以纯Python代码的运行速度在传统编译语言和传统解释语言之间。</p><p>Python编译和执行源代码的系统是同一个系统，在Python中编译器总在运行中出现，并且是运行程序系统中的一部分，在程序开始执行之前不需要预编译和连接。<br>Python代码是可以动态地修改的，所以用Python可以实现产品的定制。<br>在Python中所有的事情都是程序运行时才发生的，不需要初始的编译阶段。</p><h1 id="执行优化的工具"><a href="#执行优化的工具" class="headerlink" title="执行优化的工具"></a>执行优化的工具</h1><h2 id="Psyco实时编译器-JIT"><a href="#Psyco实时编译器-JIT" class="headerlink" title="Psyco实时编译器(JIT)"></a>Psyco实时编译器(JIT)</h2><p>Psyco系统是一个扩展字节码执行模块的组建，一个PVM的增强工具。Psyco可以将部分程序的字节码转化为二进制机器代码(字节码的转化与程序运行同时发生)，在开发过程中也无需修改或独立的编译步骤。<br>理想情况下，Psyco优化的Python代码的执行速度可跟C代码一样快。<br>Psyco最大的缺点是只能够为Intel x86构架的芯片生成机器代码。</p><h2 id="Shedskin-C-转换器"><a href="#Shedskin-C-转换器" class="headerlink" title="Shedskin C++转换器"></a>Shedskin C++转换器</h2><p>Shedskin是一个引擎系统，是一种平台无关的方式来运行Python代码。(Python代码→C++代码→使用机器中的C++编译器将C++代码编译为机器代码)</p><h1 id="交互提示模式下编写代码"><a href="#交互提示模式下编写代码" class="headerlink" title="交互提示模式下编写代码"></a>交互提示模式下编写代码</h1><h2 id="使用交互提示模式"><a href="#使用交互提示模式" class="headerlink" title="使用交互提示模式"></a>使用交互提示模式</h2><p>初学者牢记技巧：</p><p>1.只能够输入Python命令</p><p>2.文件中的打印语句是必须的，如print</p><p>3.交互提示模式下不需要缩进</p><p>4.留意提示符的变换和复合语句：CTRL+C可以返回主提示模式</p><p>5.交互模式中用一个空行结束符合语句：按下两次ENTER</p><p>6.交互模式中一次运行一条语句</p><h1 id="系统命令行和文件"><a href="#系统命令行和文件" class="headerlink" title="系统命令行和文件"></a>系统命令行和文件</h1><h2 id="使用命令行运行文件"><a href="#使用命令行运行文件" class="headerlink" title="使用命令行运行文件"></a>使用命令行运行文件</h2><p>流重定向(stream redirection)：用于文本的输入和输出。</p><p>如需要把script.py的输出行存储到saveit.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span> python script.py &gt; saveit.txt</span><br></pre></td></tr></table></figure><p>在较新版的win上可以只输入脚本的名字，并省略掉Python本身的名字，因为新的win系统使用win注册表找到用哪个程序来运行一个文件(这个命令行模式的实质类似于UNIX #!)。</p><h2 id="UNIX可执行脚本"><a href="#UNIX可执行脚本" class="headerlink" title="UNIX可执行脚本(#!)"></a>UNIX可执行脚本(#!)</h2><p>UNIX风格的可执行脚本有两个特殊的属性：</p><ul><li>脚本的第一行往往以#！(hash bang)开始，其后紧跟着Python解释器的路径（win的dos系统shell会完全忽略它）</li><li>脚本往往具有可执行的权限，可使用chmod+x <em>file.py</em>来实现</li></ul><p>在一些UNIX系统上也可以使用env来避免硬编码Python解释器的路径，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/usr/bin/env python</span></span><br></pre></td></tr></table></figure><p>env程序可以通过系统的搜索路径的设置定位Python解释器，这种方法可以代码更具可移植性(env在任何系统中都是相同的路径的前提下)。</p><h1 id="点击文件图标"><a href="#点击文件图标" class="headerlink" title="点击文件图标"></a>点击文件图标</h1><h2 id="input的技巧"><a href="#input的技巧" class="headerlink" title="input的技巧"></a>input的技巧</h2><p>如果需要利用图标点击运行脚本，脚本输出后暂停，需要在脚本的最后添加内置input函数的一条调用语句(Python3.0的input()或Python2.6中的raw_input，它们会直接把输入的文本作为一个字符串返回。而在Python2,6中的input()会对字符串求值，在Python3.0中模拟Python2.6中的input需要使用eval(input()))。</p><p>在输入时所使用的input调用相当于在输出时使用的打印语句。</p><p>在Win中还有一种完全阻止弹出DOS终端的方法：以pyw为扩展名的文件只显示由脚本构建的窗口，而不是默认的DOS终端窗口。pyw文件是拥有这种特别窗口的操作行为的,py文件。</p><h1 id="模块的导入和重载"><a href="#模块的导入和重载" class="headerlink" title="模块的导入和重载"></a>模块的导入和重载</h1><p>导入是个开销很大的操作，所以每个文件或程序运行不能重复多于一次。</p><p>但如果需要Python在同一次会话中再次运行文件，需要调用imp标准库模块中可用的reload函数(Python2.6中内置)。在重载之前需要确保已经成功导入了这个模块。</p><h2 id="模块的重要特性：属性"><a href="#模块的重要特性：属性" class="headerlink" title="模块的重要特性：属性"></a>模块的重要特性：属性</h2><p>一般意义上说，模块往往是变量名的封装，被认作是命名空间。</p><p>属性就是绑定在特地的对象上的变量名(就像一个模块)。</p><p>表面上看一个模块文件的变量名可以通过import和from两个Python语句以及reload调用。</p><p>from复制了模块的属性，以便属性能够成为接收者的直接变量。</p><p>内置的dir函数可以用于获得模块内部可用的变量名列表。</p><p>模块文件在代码文件中起到了最小化命名冲突的作用。</p><h2 id="import和reload的使用注意事项"><a href="#import和reload的使用注意事项" class="headerlink" title="import和reload的使用注意事项"></a>import和reload的使用注意事项</h2><p>reload是不可传递的，重载一个模块只会重载该模块，不会重载该模块所导入的任何模块。</p><p>Python将会从列在sys.path中的所有目录搜索被导入的模块。</p><h2 id="使用exec运行模块文件"><a href="#使用exec运行模块文件" class="headerlink" title="使用exec运行模块文件"></a>使用exec运行模块文件</h2><p>从交互提示模式启动文件而不必导入以及随后重载的方法(Python2.6)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec(open(‘module.py’).read())  <span class="comment">#方法一</span></span><br><span class="line">execfile(<span class="string">'module.py'</span>) <span class="comment">#方法二</span></span><br></pre></td></tr></table></figure><p>每次exec都运行文件的最新版本。</p><p>exec从技术上不会导入模块，默认情况下它都重新运行文件，对当前正在使用的变量有潜在的默认覆盖的可能。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
