<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>部署操作系统</title>
      <link href="/2018/07/08/cjjd5tnvy000rigvyx1mon0nf/"/>
      <url>/2018/07/08/cjjd5tnvy000rigvyx1mon0nf/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Artificial Intelligence：Its Roots and Scope</title>
      <link href="/2018/07/08/cjjd5tnui0000igvyem92zikm/"/>
      <url>/2018/07/08/cjjd5tnui0000igvyem92zikm/</url>
      <content type="html"><![CDATA[<blockquote><p><em>Invention, it must be humbly admitted, does not consist in creating out of void, but out of chaos; the materials must, in the first place, be afforded….</em> </p><p>—MARY SHELLEY, Frankenstein</p></blockquote><h2 id="Artificial-Intelligence-An-Attempted-Definition"><a href="#Artificial-Intelligence-An-Attempted-Definition" class="headerlink" title="Artificial Intelligence: An Attempted Definition"></a>Artificial Intelligence: An Attempted Definition</h2><p>For many reasons, the initial definition of artificial intelligence falls short of unambiguously defining the field. If anything, it has only led to further questions and the paradoxical notion of a field of study whose major goals include its own definition.</p><p>For the time being, we will simply define AI as the collection of problems and methodologies studied by AI researchers.</p><h1 id="AI-EARLY-HISTORY-AND-APPLICATIONS"><a href="#AI-EARLY-HISTORY-AND-APPLICATIONS" class="headerlink" title="AI: EARLY HISTORY AND APPLICATIONS"></a>AI: EARLY HISTORY AND APPLICATIONS</h1><blockquote><p><em>All men by nature desire to know…</em></p><p>—ARISTOTLE, Opening sentence of the <em>Metaphysics</em></p></blockquote><h2 id="From-Eden-to-ENIAC-Attitude-toward-Intelligence-Knowledge-and-Human-Artifice"><a href="#From-Eden-to-ENIAC-Attitude-toward-Intelligence-Knowledge-and-Human-Artifice" class="headerlink" title="From Eden to ENIAC: Attitude toward Intelligence,Knowledge, and Human Artifice"></a>From Eden to ENIAC: Attitude toward Intelligence,Knowledge, and Human Artifice</h2>]]></content>
      
      <categories>
          
          <category> Artificial Intelligence </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_English </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>隐马尔可夫模型</title>
      <link href="/2018/07/07/cjjd5tnvz000vigvystz6i2ci/"/>
      <url>/2018/07/07/cjjd5tnvz000vigvystz6i2ci/</url>
      <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>隐马尔可夫模型是关于时序的概率模型，可用于标注问题 (状态对应标记)，描述由隐藏的马尔可夫链随机生成观测序列的过程 (一个隐藏的马尔可夫链随机生成不可观测的状态随机序列→由各个状态生成一个观测而产生观测随机序列)，属于生成模型。</p><p>序列的每一个位置又可以看作是一个时刻。</p><p>隐马尔可夫模型由初始概率分布、状态转移分布、观测概率分布确定，所以初始状态概率向量$\pi$、状态转移概率矩阵$A$、观测概率矩阵$B$为隐马尔可夫模型$\lambda$的三要素：</p><center>$\lambda=(A,B,\pi)$</center><p>其中，初始状态概率向量$\pi$和状态转移概率矩阵$A$决定状态序列 (状态序列是隐藏的)，观测概率矩阵$B$决定观测序列。</p><center>$A=[a_{ij}]_{N \times M}$</center><p>$a_{ij}=P(i_{i+1}=q_i | i_t=q_i); i=1,2 \cdots ,N; j=1,2, \cdots ,N$ 代表时刻$t$处于状态$q_i$的条件下在时刻$t+1$转移到状态$q_j$的概率。$N$是可能的状态数，$M$是可能的观测数。</p><center>$B=[b_j(k)]_{N \times M}$</center><p>$b_j(k)=P(o_t=v_k | i_t=q_j) ; k=1,2, \cdots ,M ; j=1,2, \cdots ,N$ 是时刻$t$处于状态$q_j$的条件下生成观测$v_k$的概率。</p><center>$\pi =(\pi_i)$</center><p>$\pi =P(i_1=q_i),i=1,2, \cdots ,N$ 是时刻$t$=1处于状态$q_i$的概率。</p><p>$A$与$\pi$决定了隐藏的马尔可夫链，生成不可观测的状态序列。$B$确定了如何从状态生成观测，与状态序列综合确定了如何产生观测序列。</p><p>隐马尔可夫模型做了两个基本假设：</p><ol><li>齐次马尔可夫性假设：<strong>隐藏的马尔可夫链</strong>在任意时刻t的状态只依赖于<strong>前一时刻的状态</strong>。</li><li>观测独立性假设：任意时刻的<strong>观测</strong>只依赖于<strong>该时刻的马尔可夫链的状态</strong>。</li></ol><h2 id="观测序列的生成过程"><a href="#观测序列的生成过程" class="headerlink" title="观测序列的生成过程"></a>观测序列的生成过程</h2><p>输入：$\lambda=(A,B,\pi)$，观测序列长度$T$;</p><p>输出：观测序列$O=(o_1,o_2, \cdots ,o_T)$</p><p>​    (1)按照初始状态分布$\pi$产生状态$i_1$</p><p>​    (2)另$t=1$</p><p>​    (3)按照状态$i_t$的观测概率分布$b_{i_t}(k)$生成$o_t$</p><p>​    (4)按照状态$i_t$的状态转移概率分布$\{ a_{i_t i_{t+1}} \}$产生状态 $i_{t+1},i_{t+1}=1,2, \cdots ,N$</p><p>​    (5)令$t=t+1$; 如果$t&lt;T$, 转步(3)；否则，终止</p><p>即生成初始状态分布→生成观测概率分布→生成状态概率分布</p><h2 id="模型的三个基本问题"><a href="#模型的三个基本问题" class="headerlink" title="模型的三个基本问题"></a>模型的三个基本问题</h2><p>1.概率计算问题：给定模型$\lambda$和长度为T的观测序列$O=(o_1,o_2, \cdots ,o_T)$，计算模型$\lambda$下观测序列$O$出现的概率$P(O|\lambda)$。</p><p>2.学习问题(用极大似然估计的方法估计参数)：已知观测序列，估计模型的参数，使得在该模型下观测序列概率$P$最大。</p><p>3.预测问题(解码问题;给定观测序列，求最有可能的对应的状态序列)：已知模型和观测序列，求对给定观测序列条件概率$P(I | O)$最大的状态序列$I=(i_1,i_2, \cdots ,i_T)$。</p><h1 id="概率计算算法"><a href="#概率计算算法" class="headerlink" title="概率计算算法"></a>概率计算算法</h1>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Mathjax</title>
      <link href="/2018/07/06/cjjd5tnuy0002igvyizkk3dqq/"/>
      <url>/2018/07/06/cjjd5tnuy0002igvyizkk3dqq/</url>
      <content type="html"><![CDATA[<p>NexT有自带Mathjax，所以启用Mathjax的方法也非常简单，只要修改主题目录内_config.yml中的MathJax Support</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><p>注意：三句都得修改。</p>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用什么工具写博客</title>
      <link href="/2018/07/06/cjjd5tnvd000digvyklu2wkug/"/>
      <url>/2018/07/06/cjjd5tnvd000digvyklu2wkug/</url>
      <content type="html"><![CDATA[<p>我在写博客的过程中使用到了两种工具：Typora和Sublime</p><p>Sublime就不用多说了，Typora比Sublime好的一点在于它所见即所得。用两个编辑器写出来的博文格式也有点区别,Sublime没有那么支持中文。</p><p>但是如果用了本地预览，用Sublime修改博文可以立马看到效果，而Typora就无法得到(修改的那篇博文会编程Untitled)，需要重新启用hexo s。</p><p>为了能够得到所见即所得的效果，我后来使用了Typora作为写博客的工具，但是在使用过程中我发现在用Typora编辑博文时不小心把源文件给删掉了，Typora中编辑好的、保存过的文件内容也会一并消失，需要在偏好设置里手动勾选自动保存按钮，而使用Sublime并不会出现这种问题。</p><p>个人觉得为了保险起见还是应该把博文做个备份，可以把所有博文投放在另一个博客平台上，也可以在电脑里专门建一个备份文件夹，把所有源文件复制进去。</p><p>如果想直接在电脑里备份，为了方便可以用上批处理(xcopy)和计划任务(taskschd.msc)，可以省力不少。</p>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我们的宇宙图像</title>
      <link href="/2018/07/03/cjjd5tnvd000eigvy3brgy5gv/"/>
      <url>/2018/07/03/cjjd5tnvd000eigvy3brgy5gv/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> astronomy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>绪论</title>
      <link href="/2018/07/03/cjjd5tnvd000kigvyvfyc9463/"/>
      <url>/2018/07/03/cjjd5tnvd000kigvyvfyc9463/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NexT主题内建归档categories时出现的bug</title>
      <link href="/2018/07/03/cjjd5tnuy0008igvyihjlxi8h/"/>
      <url>/2018/07/03/cjjd5tnuy0008igvyihjlxi8h/</url>
      <content type="html"><![CDATA[<p>我建博客的目的是为了把我的读书笔记迁移下，然后个人更偏爱把各分类放在menu里而不是categories里，所以使用了<a href="https://www.zhihu.com/question/33324071" target="_blank" rel="noopener">内建归档categories</a>。 </p><p>在本地预览时一切ok，但是当我上传到github之后自定义的分类menu无法打开，总是出现404错误，试过了n多方法，网上也搜了一大圈，可是就是无法解决这个bug。</p><p>之后我把../public/categories/…里所有的index.html都打开来看了一遍，并没有发现什么问题，然后试着把artificial-intelligence文件夹(我categories里第一个归档文件夹就是这个)里的index.html复制黏贴替换了categories文件夹里的index.html(categories里的归档文件夹数目根据分类个数而定，但是index.html只有一个)。</p><p>然后重新上传了一次，bug没了…..</p><p>╮(╯▽╰)╭</p>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/2018/07/02/cjjd5tnvw000oigvy72v4k8cd/"/>
      <url>/2018/07/02/cjjd5tnvw000oigvy72v4k8cd/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Computer Networks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>统计学习方法概论</title>
      <link href="/2018/07/01/cjjd5tnvd000iigvyszv3rj4m/"/>
      <url>/2018/07/01/cjjd5tnvd000iigvyszv3rj4m/</url>
      <content type="html"><![CDATA[<h1 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>建立在计算机及网络之上</li><li>以数据为研究对象</li><li>目的是对数据进行预测与分析</li><li>以方法为中心</li></ol><p>按照Herbert A.Simon的观点，统计学习是计算机系统通过运用数据及统计方法提高系统性能的机器学习。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>统计学习(统计机器学习 Statistical Machine Learning)关于数据的假设(也是统计学习的前提)是同类数据(同种性质的数据)具有一定的统计规律性。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>假设空间(hypothesis space)：</strong>学习模型的集合。<br><strong>统计学习方法的三要素：</strong>模型(model;模型的假设空间)、策略(strategy;模型选择的准则)、算法(algorithm;模型学习的算法)<br><strong>实现统计学习方法的步骤：</strong> 得到有限的训练数据集合→确定学习模型的集合→确定学习的策略→实现学习的算法→选择最优模型→对数据进行预测或分析</p><h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>实例通常由特征向量表示，模型实际都是定义在特征空间上的。<br><strong>回归问题：</strong>输入变量与输出变量均为连续变量。<br><strong>分类问题：</strong>输出变量为有限个离散变量。<br><strong>标注问题：</strong>输入变量与输出变量均为变量序列。<br>监督学习关于数据的基本假设是输入与输出的随机变量X和Y具有联合概率分布。(训练数据与测试数据被看作是依联合概率分布P(X,Y)独立同分布产生的)</p><h1 id="统计学习三要素"><a href="#统计学习三要素" class="headerlink" title="统计学习三要素"></a>统计学习三要素</h1><p> 方法=模型+策略+算法</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>非概率模型由决策函数表示，概率模型由条件概率表示</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p><strong>损失函数：</strong>度量模型一次预测的好坏。<br><strong>风险函数：</strong>度量平均意义下模型预测的好坏。</p><h3 id="损失函数和风险函数"><a href="#损失函数和风险函数" class="headerlink" title="损失函数和风险函数"></a>损失函数和风险函数</h3>]]></content>
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction About AI</title>
      <link href="/2018/06/30/cjjd5tnuy0006igvyvm92z97f/"/>
      <url>/2018/06/30/cjjd5tnuy0006igvyvm92z97f/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Artificial Intelligence </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_English </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python使用入门及如何运行</title>
      <link href="/2018/06/28/cjjd5tnvd0009igvyzoc5hxak/"/>
      <url>/2018/06/28/cjjd5tnvd0009igvyzoc5hxak/</url>
      <content type="html"><![CDATA[<p>这篇没涉及什么技术性知识，只是用于帮助了解Python而已。</p><h1 id="选择Python的主要因素"><a href="#选择Python的主要因素" class="headerlink" title="选择Python的主要因素"></a>选择Python的主要因素</h1><p>软件质量、提高开发者的效率、程序的可移植性、标准库的支持、组件集成、享受乐趣</p><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>Python的特性是以统一并有限的方式进行交互。<br>Python的设计理念是极简主义，”EIBTI”，明了胜于晦涩。(import this)</p><h1 id="Python的定义"><a href="#Python的定义" class="headerlink" title="Python的定义"></a>Python的定义</h1><p>Python一般可以定义为面向对象的脚本语言。<br>“脚本”倾向于描述简单的顶层代码文件，”程序”用来描述相对复杂的多文件应用。<br>Python的三个角色：Shell工具、控制语言(常规角色)、使用便捷(通常应用于快速作业任务和长期战略开发)</p><h1 id="Python的缺点"><a href="#Python的缺点" class="headerlink" title="Python的缺点"></a>Python的缺点</h1><p>速度没C和C++快，因为Python没有将代码编译成底层的二进制代码。<br>在一些需要优化程序执行速度的应用领域，如数值计算和动画，可以通过分离一部分需要优化速度的应用，将其变化为编译好的扩展，仍可以使用Python。</p><h1 id="程序执行-Python视角"><a href="#程序执行-Python视角" class="headerlink" title="程序执行-Python视角"></a>程序执行-Python视角</h1><h2 id="字节码编译，PVM，性能和开发的含义"><a href="#字节码编译，PVM，性能和开发的含义" class="headerlink" title="字节码编译，PVM，性能和开发的含义"></a>字节码编译，PVM，性能和开发的含义</h2><p><strong>解释器：</strong>代码和机器的计算机硬件之间的软件逻辑层<br><strong>python的运行步骤:</strong> 源代码(.py)→字节码(.pyc)→PVM(Python Virtual Machine)<br>PVM实际上是迭代运行字节码指令的一个大循环，是Python的运行引擎，是实际运行脚本的组建。<br>Python的字节码非机器的二进制代码，它具有可移植性。<br>Python没有”build”和”make”步骤，代码在写好之后立即运行，所以纯Python代码的运行速度在传统编译语言和传统解释语言之间。</p><p>Python编译和执行源代码的系统是同一个系统，在Python中编译器总在运行中出现，并且是运行程序系统中的一部分，在程序开始执行之前不需要预编译和连接。<br>Python代码是可以动态地修改的，所以用Python可以实现产品的定制。<br>在Python中所有的事情都是程序运行时才发生的，不需要初始的编译阶段。</p><h1 id="执行优化的工具"><a href="#执行优化的工具" class="headerlink" title="执行优化的工具"></a>执行优化的工具</h1><h2 id="Psyco实时编译器-JIT"><a href="#Psyco实时编译器-JIT" class="headerlink" title="Psyco实时编译器(JIT)"></a>Psyco实时编译器(JIT)</h2><p>Psyco系统是一个扩展字节码执行模块的组建，一个PVM的增强工具。Psyco可以将部分程序的字节码转化为二进制机器代码(字节码的转化与程序运行同时发生)，在开发过程中也无需修改或独立的编译步骤。<br>理想情况下，Psyco优化的Python代码的执行速度可跟C代码一样快。<br>Psyco最大的缺点是只能够为Intel x86构架的芯片生成机器代码。</p><h2 id="Shedskin-C-转换器"><a href="#Shedskin-C-转换器" class="headerlink" title="Shedskin C++转换器"></a>Shedskin C++转换器</h2><p>Shedskin是一个引擎系统，是一种平台无关的方式来运行Python代码。(Python代码→C++代码→使用机器中的C++编译器将C++代码编译为机器代码)</p><h1 id="交互提示模式下编写代码"><a href="#交互提示模式下编写代码" class="headerlink" title="交互提示模式下编写代码"></a>交互提示模式下编写代码</h1><h2 id="使用交互提示模式"><a href="#使用交互提示模式" class="headerlink" title="使用交互提示模式"></a>使用交互提示模式</h2><p>初学者牢记技巧：</p><p>1.只能够输入Python命令</p><p>2.文件中的打印语句是必须的，如print</p><p>3.交互提示模式下不需要缩进</p><p>4.留意提示符的变换和复合语句：CTRL+C可以返回主提示模式</p><p>5.交互模式中用一个空行结束符合语句：按下两次ENTER</p><p>6.交互模式中一次运行一条语句</p><h1 id="系统命令行和文件"><a href="#系统命令行和文件" class="headerlink" title="系统命令行和文件"></a>系统命令行和文件</h1><h2 id="使用命令行运行文件"><a href="#使用命令行运行文件" class="headerlink" title="使用命令行运行文件"></a>使用命令行运行文件</h2><p>流重定向(stream redirection)：用于文本的输入和输出。</p><p>如需要把script.py的输出行存储到saveit.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span> python script.py &gt; saveit.txt</span><br></pre></td></tr></table></figure><p>在较新版的win上可以只输入脚本的名字，并省略掉Python本身的名字，因为新的win系统使用win注册表找到用哪个程序来运行一个文件(这个命令行模式的实质类似于UNIX #!)。</p><h2 id="UNIX可执行脚本"><a href="#UNIX可执行脚本" class="headerlink" title="UNIX可执行脚本(#!)"></a>UNIX可执行脚本(#!)</h2><p>UNIX风格的可执行脚本有两个特殊的属性：</p><ul><li>脚本的第一行往往以#！(hash bang)开始，其后紧跟着Python解释器的路径（win的dos系统shell会完全忽略它）</li><li>脚本往往具有可执行的权限，可使用chmod+x <em>file.py</em>来实现</li></ul><p>在一些UNIX系统上也可以使用env来避免硬编码Python解释器的路径，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/usr/bin/env python</span></span><br></pre></td></tr></table></figure><p>env程序可以通过系统的搜索路径的设置定位Python解释器，这种方法可以代码更具可移植性(env在任何系统中都是相同的路径的前提下)。</p><h1 id="点击文件图标"><a href="#点击文件图标" class="headerlink" title="点击文件图标"></a>点击文件图标</h1><h2 id="input的技巧"><a href="#input的技巧" class="headerlink" title="input的技巧"></a>input的技巧</h2><p>如果需要利用图标点击运行脚本，脚本输出后暂停，需要在脚本的最后添加内置input函数的一条调用语句(Python2.6中的raw_input)。</p><p>在输入时所使用的input调用相当于在输出时使用的打印语句。</p><p>在Win中还有一种完全阻止弹出DOS终端的方法：以pyw为扩展名的文件</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic_Chinese </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
